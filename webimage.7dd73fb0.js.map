{"version":3,"sources":["../node_modules/geotiff/dist-module/compression/webimage.js"],"names":["WebImageDecoder","BaseDecoder","constructor","createImageBitmap","Error","document","OffscreenCanvas","fileDirectory","buffer","blob","Blob","imageBitmap","canvas","createElement","width","height","ctx","getContext","drawImage","getImageData","data"],"mappings":";AAQyD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EARzD,IAAA,EAAA,EAAA,QAAA,qBAQyD,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAA1C,MAAMA,UAAwBC,EAA9B,QACbC,cAEE,GADA,QACiC,oBAAtBC,kBACT,MAAM,IAAIC,MAAM,kEACX,GAAwB,oBAAbC,UAAuD,oBAApBC,gBACnD,MAAM,IAAIF,MAAM,uFAIR,aAACG,EAAeC,GAC1B,MAAMC,EAAO,IAAIC,KAAK,CAACF,IACjBG,QAAoBR,kBAAkBM,GAE5C,IAAIG,EACoB,oBAAbP,WACTO,EAASP,SAASQ,cAAc,WACzBC,MAAQH,EAAYG,MAC3BF,EAAOG,OAASJ,EAAYI,QAE5BH,EAAS,IAAIN,gBAAgBK,EAAYG,MAAOH,EAAYI,QAG9D,MAAMC,EAAMJ,EAAOK,WAAW,MAM9B,OALAD,EAAIE,UAAUP,EAAa,EAAG,GAKvBK,EAAIG,aAAa,EAAG,EAAGR,EAAYG,MAAOH,EAAYI,QAAQK,KAAKZ,QA7BrB,QAAA,QAAA","file":"webimage.7dd73fb0.js","sourceRoot":"../examples","sourcesContent":["import BaseDecoder from './basedecoder.js';\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nexport default class WebImageDecoder extends BaseDecoder {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n\n  async decode(fileDirectory, buffer) {\n    const blob = new Blob([buffer]);\n    const imageBitmap = await createImageBitmap(blob);\n\n    let canvas;\n    if (typeof document !== 'undefined') {\n      canvas = document.createElement('canvas');\n      canvas.width = imageBitmap.width;\n      canvas.height = imageBitmap.height;\n    } else {\n      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    }\n\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(imageBitmap, 0, 0);\n\n    // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n    // it seems like GDAL always encodes via RGBA which does not require a translation\n\n    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n  }\n}\n"]}